/** * Universidade de Sao Paulo * Instituto de Ciencias Matematicas e de Computacao *  * SCC0205 Teoria da Computacao e Linguagens Formais * Trabalho 1 - Analisador Lexico para Linguagem AWK *  * Elias Italiano Rodrigues         7987251 * Gabriel Tessaroli Giancristofaro 4321350 * Paulo Augusto de Godoy Patire    7987060 */options{	JDK_VERSION = "1.5";	static = true; }PARSER_BEGIN(AWK)public class AWK {	public static void main(String args []) throws ParseException  {		AWK AwkParser = new AWK(System.in);		System.out.println("Reading awk program from standard input...");		SimpleNode root = AwkParser.Parse();		root.dump("");	}}PARSER_END(AWK)// Definicao dos caracteres que devem ser ignoradosSKIP:{	" " | "\r" | "\t" | "\n"}// Final de instrucaoTOKEN:{	<ENDLINE: ";">}// Palavras reservadasTOKEN:{	<BEGIN:       "BEGIN">|	<END:         "END">|	<ARGC:        "ARGC">|	<ARGIND:      "ARGIND">|	<ARGV:        "ARGV">|	<BINMODE:     "BINMODE">|	<CONVFMT:     "CONVFMT">|	<ENVIRON:     "ENVIRON">|	<ERRNO:       "ERRNO">|	<FIELDWIDTHS: "FIELDWIDTHS">|	<FILENAME:    "FILENAME">|	<FNR:         "FNR">|	<FS:          "FS">|	<IGNORECASE:  "IGNORECASE">|	<LINT:        "LINT">|	<NF:          "NF">|	<NR:          "NR">|	<OFMT:        "OFMT">|	<OFS:         "OFS">|	<ORS:         "ORS">|	<PROCINFO:    "PROCINFO">|	<RS:          "RS">|	<RT:          "RT">|	<RSTART:      "RSTART">|	<RLENGTH:     "RLENGTH">|	<SUBSEP:      "SUBSEP">|	<TEXTDOMAIN:  "TEXTDOMAIN">}// Comandos da linguagemTOKEN:{	<IF:       "if">|	<ELSE:     "else">|	<DO:       "do">|	<WHILE:    "while">|	<FOR:      "for">|	<IN:       "in">|	<DELETE:   "delete">|	<BREAK:    "break">|	<CONTINUE: "continue">|	<NEXT:     "next">|	<EXIT:     "exit">|	<RETURN:   "return">|	<PRINT:    "print">|	<GETLINE:  "getline">}// LiteraisTOKEN:{	<ID: ("_" | <LETTER>) ("_" | <LETTER> | <DIGIT>)* >|	<INTEGER: ("+" | "-")? (["0"-"9"])+>|	<FLOAT: ("+" | "-")? ((["0"-"9"])+)? "." (["0"-"9"])+>|	<ASSIGN: "="|"-="|"+="|"/="|"*="|"%="|"^=" >|	<COMPARISON: ">="|">"|"=="|"!="|"<="|"<" >|	<SINGLE_SIGN: ("+"|"-")>|	<ARITHMETIC: "-" | "+"  | "%"  |  "/" | "*" >|	<STRING: "\"" ((<CHAR>)+)? "\"">|		<#CHAR: (<ALPHA_NUMERIC>) | (<SYMBOL>)>|		<#ALPHA_NUMERIC: (<LETTER> | <DIGIT>)+>|		<#LETTER: ["a"-"z"] | ["A"-"Z"]>|		<#DIGIT: ["0"-"9"]>|		<#SYMBOL: " " | "!" | "\"" | "#" | "$" | "%" | "&" | "\'" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?" | "@" | "[" | "\\" | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~">}// RegrasSimpleNode Parse() #PROGRAM : { }{	Program() { return jjtThis; }}void Program() : {}{	(BeginCurly() | EndCurly() | EndLine() | BeginParenthesis() | EndParenthesis() | 	IfLiteral() | ElseLiteral() | WhileLiteral() | DoLiteral() | ForLiteral() | InLiteral() |	DeleteLiteral() | BeginBracket() | EndBracket() | Exit() | Return() | Print() | GetLine() |	Comma() | Variable() | AssignLiteral() | QuestionMark() | Colon() | AndOr() |	ComparisonLiteral() | ArithmeticLiteral() | SingleSignLiteral() | ExpoLiteral() |	UnaryOpLiteral() | Constant() | Pattern())*}void BeginCurly() #$BEGIN_CURLY : {Token t;} {	t="{" 	{jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void EndCurly() #$END_CURLY : {Token t;}{	t="}"	{jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void Pattern() #$PATTERN : {Token t;}{	t=<BEGIN> 	{jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void EndLine() #$ENDLINE : {Token t;}{	t=<ENDLINE> 	{jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void BeginParenthesis() #$BEGIN_PARENTHESIS : {Token t;}{	t="(" {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void EndParenthesis() #$END_PARENTHESIS : {Token t;}{	t=")" {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void IfLiteral() #$IF : {Token t;}{	t=<IF> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void ElseLiteral() #$ELSE : {Token t;}{	t=<ELSE> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void WhileLiteral() #$WHILE : {Token t;}{	t=<WHILE> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void DoLiteral() #$DO : {Token t;}{	t=<DO> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void ForLiteral() #$FOR : {Token t;}{	t=<FOR> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void InLiteral() #$IN : {Token t;}{	t=<IN> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void IdLiteral() #$ID : {Token t;}{	t=<ID> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void DeleteLiteral() #$DELETE : {Token t;}{	t=<DELETE> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void BeginBracket() #$BEGIN_BRACKET : {Token t;}{	t="[" {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void EndBracket() #$END_BRACKET : {Token t;}{	t="]" {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void Exit() #$EXIT : {Token t;}{	t=<EXIT> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void Return() #$RETURN : {Token t;}{	t=<RETURN> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void Print() #$PRINT : {Token t;}{	t=<PRINT> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void GetLine() #$GETLINE : {Token t;}{	t=<GETLINE> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void Comma() #$COMMA : {Token t;}{	t="," {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void Variable() #$VARIABLE : {Token t;}{	(t=<ID> | t="$" | t=<ARGC> | t=<ARGIND> | t=<ARGV> | t=<BINMODE> | t=<CONVFMT> | t=<ENVIRON> | t=<ERRNO>	| t=<FIELDWIDTHS> | t=<FILENAME> | t=<FNR> | t=<FS> | t=<IGNORECASE> | t=<LINT>| t=<NF>| t=<NR>| t=<OFMT>	| t=<OFS> | t=<ORS> | t=<PROCINFO> | t=<RS> | t=<RT> | t=<RSTART> | t=<RLENGTH> | t=<SUBSEP> | t=<TEXTDOMAIN>)	{jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void AssignLiteral() #$ASSIGN : {Token t;}{	t=<ASSIGN> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void QuestionMark() #$QUESTION_MARK : {Token t;}{	t="?" {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void Colon() #$COLON : {Token t;}{	t=":" {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void AndOr() #$AND_OR : {Token t;}{	(t="||"|t="&&") {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void ComparisonLiteral() #$COMPARISON : {Token t;}{	t=<COMPARISON> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void ArithmeticLiteral() #$ARITHMETIC : {Token t;}{	t=<ARITHMETIC> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void SingleSignLiteral() #$SINGLE_SIGN : {Token t;}{	t=<SINGLE_SIGN> {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void ExpoLiteral() #$EXPO : {Token t;}{	t="^" {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void UnaryOpLiteral() #$UNARY_OP : {Token t;}{	(t="--" | t="++") {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}void Constant() #$CONSTANT : {Token t;}{	(t=<INTEGER> | t=<FLOAT> | t=<STRING>) {jjtThis.value = t.image; jjtThis.line = t.beginLine; jjtThis.column = t.beginColumn;}}